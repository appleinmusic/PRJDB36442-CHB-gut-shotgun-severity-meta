#!/usr/bin/env python3
from __future__ import annotations

import argparse
import csv
from pathlib import Path


def _read_tsv(path: Path) -> list[dict[str, str]]:
    with path.open("r", encoding="utf-8", newline="") as f:
        return list(csv.DictReader(f, delimiter="\t"))


def main() -> int:
    ap = argparse.ArgumentParser(description="Join PRJDB36442 runâ†’group mapping with MetaPhlAn per-run QC fields.")
    ap.add_argument(
        "--run-groups",
        type=Path,
        default=Path("results/feasibility/PRJDB36442_run_groups.tsv"),
        help="Input TSV mapping run_accession to group and BioSample IDs.",
    )
    ap.add_argument(
        "--qc",
        type=Path,
        default=Path("results/processed/metaphlan/PRJDB36442_metaphlan_qc.tsv"),
        help="MetaPhlAn QC TSV generated by scripts/postprocess/metaphlan_qc_from_outputs.py.",
    )
    ap.add_argument(
        "--out",
        type=Path,
        default=Path("results/processed/metadata/PRJDB36442_sample_sheet.tsv"),
        help="Output TSV (default: results/processed/metadata/PRJDB36442_sample_sheet.tsv).",
    )
    args = ap.parse_args()

    run_rows = _read_tsv(args.run_groups)
    qc_rows = _read_tsv(args.qc)

    qc_by_run: dict[str, dict[str, str]] = {r["sample_id"]: r for r in qc_rows if r.get("sample_id")}

    out_rows: list[dict[str, str]] = []
    for r in run_rows:
        run = r.get("run_accession", "")
        if not run:
            continue
        qc = qc_by_run.get(run, {})
        out_rows.append(
            {
                "run_accession": run,
                "group": r.get("group", ""),
                "sample_alias": r.get("sample_alias", ""),
                "ngdc_sample_name": r.get("ngdc_sample_name", ""),
                "ngdc_sample_accession": r.get("ngdc_sample_accession", ""),
                "reads_processed": qc.get("reads_processed", ""),
                "db_id": qc.get("db_id", ""),
                "metaphlan_output_path": qc.get("path", ""),
                "metaphlan_command": qc.get("command", ""),
            }
        )

    out_rows.sort(key=lambda x: x["run_accession"])
    args.out.parent.mkdir(parents=True, exist_ok=True)
    with args.out.open("w", encoding="utf-8", newline="") as f:
        w = csv.DictWriter(
            f,
            fieldnames=[
                "run_accession",
                "group",
                "sample_alias",
                "ngdc_sample_name",
                "ngdc_sample_accession",
                "reads_processed",
                "db_id",
                "metaphlan_output_path",
                "metaphlan_command",
            ],
            delimiter="\t",
        )
        w.writeheader()
        w.writerows(out_rows)

    print(str(args.out))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
